@page "/"
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using ImpossibleSurvivalRace2.Server.Hubs
@using ImpossibleSurvivalRace2.Services
@using Microsoft.AspNetCore.SignalR
@using Microsoft.AspNetCore.SignalR.Client
@using Blazor.Extensions.Canvas.Canvas2D
@using ImpossibleSurvivalRace2.Shared.Models
@inject NavigationManager NavigationManager
@inject IJSRuntime JsRuntime

<style>
    body {
        background-color: #EFDECD ;
    }
</style>

<PageTitle>Lobby</PageTitle>

<div class="form-group" hidden="@HasJoinedLobby">
    <div class="form-group">
        <label>
            Username: 
            <input @bind="UserNameInput" placeholder="@inputUserWarningText" />
        </label>
        <label> 
            Lobby code:
            <input @bind="codeInput" placeholder="@inputCodeWarningText" />
        </label>
        <button id="buttonCenter" class="btn btn-primary" @onclick="JoinExistingLobby">Join existing lobby</button>
    </div>
    <button id="buttonCenter2" class="btn btn-success" @onclick="InitiateNewLobby">Create new lobby</button>

</div>

<div class="form-group" hidden="@(!HasJoinedLobby || gameStarted)">

    <p>Current lobby: <b>@currentLobbyCode</b></p>

    <p>Lobby messages:</p>
    <ul id="messagesList">
        @foreach (var message in messages)
        {
            <li>@message</li>
        }
    </ul>

    <button id="buttonCenter3" class="btn btn-success" hidden="@(!IsCreator)" @onclick="Startgame">Start game</button>
</div>

<div @ref=@(testRef) tabindex="1" @onkeydown="@Move" hidden="@gameStarted">
<BECanvas Width="@Width" Height="@Height"  @ref="_canvasReference"> </BECanvas>
</div>

@code {
    //map variables
    Canvas2DContext _context;
    BECanvasComponent _canvasReference;
    int outer=0;
    int inner=30;
    int Width=1400;
    int Height=500;
    string mapColor="#9F8170";

    int startLineCenterX;
    int startLineCenterY;

    //other variables
    private Player player = null;
    private HubConnection? hubConnection;
    private ILobbyService lobbyService;

    bool gameStarted = false;
    private bool HasJoinedLobby = false;
    private bool HasBeenSpawned = false;
    private bool IsCreator = false;
    private string currentLobbyCode = "-";

    private string? UserNameInput;
    private string? codeInput;

    private string? inputUserWarningText;
    private string? inputCodeWarningText;

    private List<string> messages = new List<string>();
    private Player winner = new Player();

    int leftDir=10;
    int topDir=470;
    private ElementReference testRef;

    Task Move(KeyboardEventArgs e)
    {
        switch(e.Code)
        {
            case "ArrowDown":
                if(IsPlayerWithinPositiveBoundaries(topDir, Constants.PLAYER_SIZE, this.Height))
                {
                    topDir++;
                }
                break;
            case "ArrowUp":
                if (IsPlayerWithinNegativeBoundaries(topDir, Constants.PLAYER_SIZE, 0))
                {
                    topDir--;
                }
                break;
            case "ArrowLeft":
                if (IsPlayerWithinNegativeBoundaries(leftDir, Constants.PLAYER_SIZE, 0))
                {
                    leftDir--;
                }
                break;
            case "ArrowRight":
                if(IsPlayerWithinPositiveBoundaries(leftDir, Constants.PLAYER_SIZE, this.Width))
                {
                    leftDir++;
                }
                break;
            default:
                break;
        }
        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        this._context = await _canvasReference.CreateCanvas2DAsync();

            await _context.BeginBatchAsync();

            await testRef.FocusAsync();

            //isorinis loopas
            Line line1 = new Line(outer, outer, outer, Height, 3, mapColor);
            await DrawLine(_context, line1);

            Line line2 = new Line(outer, Height, Width, Height, 3, mapColor);
            await DrawLine(_context, line2);

            Line line3 = new Line(Width, Height, Width, outer, 3, mapColor);
            await DrawLine(_context, line3);

            Line line4 = new Line(Width, outer, outer, outer, 3, mapColor);
            await DrawLine(_context, line4);

            //vidinis loopas
            Line line5 = new Line(inner, inner, inner, Height - inner, 3, mapColor);
            await DrawLine(_context, line5);

            Line line6 = new Line(inner, Height - inner, Width - inner, Height - inner, 3, mapColor);
            await DrawLine(_context, line6);

            Line line7 = new Line(Width - inner, Height - inner, Width - inner, inner, 3, mapColor);
            await DrawLine(_context, line7);

            Line line8 = new Line(Width - inner, inner, inner, inner, 3, mapColor);
            await DrawLine(_context, line8);

            startLineCenterY = Height - inner;
            startLineCenterX = (inner - outer) / 2;

            //start line
            Line line9 = new Line(outer, Height - inner, inner, Height - inner, 3, "#A52A2A");
            await DrawLine(_context, line9);

            // Player
            await _context.ClearRectAsync(leftDir-10, topDir-10, 20, 20);
            Dot dot = new Dot(leftDir, topDir, 5, 12, Math.PI * 2, "blue");
            await DrawDot(_context, dot);
            await _context.EndBatchAsync();
    }

    private bool IsPlayerWithinPositiveBoundaries(int pos, int playerSize, int canvasMax)
    {
        return !(pos + playerSize >= canvasMax);
    }

    private bool IsPlayerWithinNegativeBoundaries(int pos, int playerSize, int canvasMin)
    {
        return !(pos - playerSize <= 0);
    }

    public static async Task DrawLine(Canvas2DContext context, Line line)
    {
        await context.BeginPathAsync();
        await context.MoveToAsync(line.startX, line.startY);
        await context.LineToAsync(line.endX, line.endY);
        await context.SetLineWidthAsync(line.thickness);

        // set line color
        await context.SetStrokeStyleAsync(line.color);
        await context.StrokeAsync();
       //  await context.EndBatchAsync();
    }

    public static async Task DrawDot(Canvas2DContext context, Dot dot)
    {
        await context.MoveToAsync(dot.startX, dot.startY);
        await context.ArcAsync(dot.startX, dot.startY, dot.radius, dot.startAngle, dot.endAngle, true);
        await context.FillAsync();
        await context.SetFillStyleAsync(dot.color);
    }

    public void Startgame()
    {
        gameStarted = true;
    }

    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/gamehub"))
            .WithAutomaticReconnect()
            .Build();

        // TODO: Check if player was in a lobby previously

        hubConnection.On<string>("JoinLobby", (message) =>
        {
            var encodedMsg = $"{message}";
            messages.Add(encodedMsg);
            InvokeAsync(StateHasChanged);
        });

        hubConnection.On<string>("RemoveFromLobby", (message) =>
        {
            var encodedMsg = $"{message}";
            messages.Add(encodedMsg);
            InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
    }

    private async Task InitiateNewLobby()
    {
        if (hubConnection is not null)
        {
            if (!string.IsNullOrWhiteSpace(UserNameInput))
            {
                inputUserWarningText = "";

                CreatePlayer(UserNameInput); // Create a player if it doesn't exist

                await hubConnection.SendAsync("CreateNewLobby", player);

                hubConnection.On<string, string>("CreateLobby", (message, lobbyCode) =>
                {
                    var encodedMsg = $"{message}";
                    currentLobbyCode = $"{lobbyCode}";
                    messages.Add(encodedMsg);
                    InvokeAsync(StateHasChanged);
                });
                IsCreator = true;
                HasJoinedLobby = true;
            }
            else
                inputUserWarningText = "Username is not valid";
        }
    }

    private async Task JoinExistingLobby()
    {
        if (hubConnection is not null)
        {
            if (!string.IsNullOrWhiteSpace(UserNameInput))
            {
                inputUserWarningText = "";
                if (!string.IsNullOrWhiteSpace(codeInput))
                {
                    inputCodeWarningText = "";
                    CreatePlayer(UserNameInput); // Create a player if doesn't exist

                    await hubConnection.SendAsync("AddToLobby", codeInput, player);
                    currentLobbyCode = $"{codeInput}";
                    HasJoinedLobby = true;
                }
                else
                    inputCodeWarningText = "Lobby code is not valid";
            }
            else
                inputUserWarningText = "Username is not valid";
        }
    }
    public Random random { get { return new Random(); } }

    private async Task SpawnPlayer(int lobbyCode)
    {
        if (HasJoinedLobby && !HasBeenSpawned)
        {
            int x;
            int y;
            List<Player> currPlayers = new List<Player>();
            string[] colorList = new string[] { "red", "purple", "green", "blue", "brown", "orange", "pink" };
            string randomColor = colorList[random.Next(0, colorList.Length - 1)];

         //   currPlayers = await lobbyService.GetPlayers(lobbyCode); neveikia

            switch (currPlayers.Count())
            {
                case 0:
                    x = startLineCenterX + 10 + currPlayers.Count() * 3;
                    y = startLineCenterY + 5;
                    Dot dot = new Dot(x, y, 5, 12, Math.PI * 2, randomColor);
                    await DrawDot(_context, dot);
                    break;
                case 1:
                    x = startLineCenterX + 10 + currPlayers.Count() * 3;
                    y = startLineCenterY + 5;
                    dot = new Dot(x, y, 5, 12, Math.PI * 2, randomColor);
                    await DrawDot(_context, dot);
                    break;
                case 2:
                    x = startLineCenterX + 10 + currPlayers.Count() * 3;
                    y = startLineCenterY + 5;
                    dot = new Dot(x, y, 5, 12, Math.PI * 2, randomColor);
                    await DrawDot(_context, dot);
                    break;
                case 3:
                    x = startLineCenterX + 10 + currPlayers.Count() * 3;
                    y = startLineCenterY + 5;
                    dot = new Dot(x, y, 5, 12, Math.PI * 2, randomColor);
                    await DrawDot(_context, dot);
                    break;
            }
        }

    }

    private void CreatePlayer(string userNameInput)
    {
        if (this.player == null)
        {
            player = new Player
            {
                ConnectionId = hubConnection.ConnectionId,
                UserName = userNameInput
            };
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.SendAsync("RemoveFromLobby", currentLobbyCode);
            await hubConnection.DisposeAsync();
        }
    }

    public enum Movement {
        Wandering,
        Strafe,
        SlowStrafe,
        Follow
    }
}
